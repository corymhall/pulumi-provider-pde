// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package installers

import (
	"context"
	"reflect"

	"errors"
	"github.com/corymhall/pulumi-provider-pde/sdk/go/pde/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type Shell struct {
	pulumi.CustomResourceState

	BinLocation       pulumi.StringPtrOutput   `pulumi:"binLocation"`
	DownloadURL       pulumi.StringOutput      `pulumi:"downloadURL"`
	Executable        pulumi.BoolPtrOutput     `pulumi:"executable"`
	InstallCommands   pulumi.StringArrayOutput `pulumi:"installCommands"`
	Location          pulumi.StringPtrOutput   `pulumi:"location"`
	ProgramName       pulumi.StringOutput      `pulumi:"programName"`
	UninstallCommands pulumi.StringArrayOutput `pulumi:"uninstallCommands"`
	UpdateCommands    pulumi.StringArrayOutput `pulumi:"updateCommands"`
	Version           pulumi.StringOutput      `pulumi:"version"`
	VersionCommand    pulumi.StringPtrOutput   `pulumi:"versionCommand"`
}

// NewShell registers a new resource with the given unique name, arguments, and options.
func NewShell(ctx *pulumi.Context,
	name string, args *ShellArgs, opts ...pulumi.ResourceOption) (*Shell, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DownloadURL == nil {
		return nil, errors.New("invalid value for required argument 'DownloadURL'")
	}
	if args.ProgramName == nil {
		return nil, errors.New("invalid value for required argument 'ProgramName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Shell
	err := ctx.RegisterResource("pde:installers:Shell", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetShell gets an existing Shell resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetShell(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ShellState, opts ...pulumi.ResourceOption) (*Shell, error) {
	var resource Shell
	err := ctx.ReadResource("pde:installers:Shell", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Shell resources.
type shellState struct {
}

type ShellState struct {
}

func (ShellState) ElementType() reflect.Type {
	return reflect.TypeOf((*shellState)(nil)).Elem()
}

type shellArgs struct {
	BinLocation       *string           `pulumi:"binLocation"`
	DownloadURL       string            `pulumi:"downloadURL"`
	Environment       map[string]string `pulumi:"environment"`
	Executable        *bool             `pulumi:"executable"`
	InstallCommands   []string          `pulumi:"installCommands"`
	Interpreter       []string          `pulumi:"interpreter"`
	ProgramName       string            `pulumi:"programName"`
	UninstallCommands []string          `pulumi:"uninstallCommands"`
	UpdateCommands    []string          `pulumi:"updateCommands"`
	VersionCommand    *string           `pulumi:"versionCommand"`
}

// The set of arguments for constructing a Shell resource.
type ShellArgs struct {
	BinLocation       pulumi.StringPtrInput
	DownloadURL       pulumi.StringInput
	Environment       pulumi.StringMapInput
	Executable        pulumi.BoolPtrInput
	InstallCommands   pulumi.StringArrayInput
	Interpreter       pulumi.StringArrayInput
	ProgramName       pulumi.StringInput
	UninstallCommands pulumi.StringArrayInput
	UpdateCommands    pulumi.StringArrayInput
	VersionCommand    pulumi.StringPtrInput
}

func (ShellArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*shellArgs)(nil)).Elem()
}

type ShellInput interface {
	pulumi.Input

	ToShellOutput() ShellOutput
	ToShellOutputWithContext(ctx context.Context) ShellOutput
}

func (*Shell) ElementType() reflect.Type {
	return reflect.TypeOf((**Shell)(nil)).Elem()
}

func (i *Shell) ToShellOutput() ShellOutput {
	return i.ToShellOutputWithContext(context.Background())
}

func (i *Shell) ToShellOutputWithContext(ctx context.Context) ShellOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ShellOutput)
}

// ShellArrayInput is an input type that accepts ShellArray and ShellArrayOutput values.
// You can construct a concrete instance of `ShellArrayInput` via:
//
//	ShellArray{ ShellArgs{...} }
type ShellArrayInput interface {
	pulumi.Input

	ToShellArrayOutput() ShellArrayOutput
	ToShellArrayOutputWithContext(context.Context) ShellArrayOutput
}

type ShellArray []ShellInput

func (ShellArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Shell)(nil)).Elem()
}

func (i ShellArray) ToShellArrayOutput() ShellArrayOutput {
	return i.ToShellArrayOutputWithContext(context.Background())
}

func (i ShellArray) ToShellArrayOutputWithContext(ctx context.Context) ShellArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ShellArrayOutput)
}

// ShellMapInput is an input type that accepts ShellMap and ShellMapOutput values.
// You can construct a concrete instance of `ShellMapInput` via:
//
//	ShellMap{ "key": ShellArgs{...} }
type ShellMapInput interface {
	pulumi.Input

	ToShellMapOutput() ShellMapOutput
	ToShellMapOutputWithContext(context.Context) ShellMapOutput
}

type ShellMap map[string]ShellInput

func (ShellMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Shell)(nil)).Elem()
}

func (i ShellMap) ToShellMapOutput() ShellMapOutput {
	return i.ToShellMapOutputWithContext(context.Background())
}

func (i ShellMap) ToShellMapOutputWithContext(ctx context.Context) ShellMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ShellMapOutput)
}

type ShellOutput struct{ *pulumi.OutputState }

func (ShellOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Shell)(nil)).Elem()
}

func (o ShellOutput) ToShellOutput() ShellOutput {
	return o
}

func (o ShellOutput) ToShellOutputWithContext(ctx context.Context) ShellOutput {
	return o
}

func (o ShellOutput) BinLocation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringPtrOutput { return v.BinLocation }).(pulumi.StringPtrOutput)
}

func (o ShellOutput) DownloadURL() pulumi.StringOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringOutput { return v.DownloadURL }).(pulumi.StringOutput)
}

func (o ShellOutput) Executable() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Shell) pulumi.BoolPtrOutput { return v.Executable }).(pulumi.BoolPtrOutput)
}

func (o ShellOutput) InstallCommands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringArrayOutput { return v.InstallCommands }).(pulumi.StringArrayOutput)
}

func (o ShellOutput) Location() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringPtrOutput { return v.Location }).(pulumi.StringPtrOutput)
}

func (o ShellOutput) ProgramName() pulumi.StringOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringOutput { return v.ProgramName }).(pulumi.StringOutput)
}

func (o ShellOutput) UninstallCommands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringArrayOutput { return v.UninstallCommands }).(pulumi.StringArrayOutput)
}

func (o ShellOutput) UpdateCommands() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringArrayOutput { return v.UpdateCommands }).(pulumi.StringArrayOutput)
}

func (o ShellOutput) Version() pulumi.StringOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringOutput { return v.Version }).(pulumi.StringOutput)
}

func (o ShellOutput) VersionCommand() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Shell) pulumi.StringPtrOutput { return v.VersionCommand }).(pulumi.StringPtrOutput)
}

type ShellArrayOutput struct{ *pulumi.OutputState }

func (ShellArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Shell)(nil)).Elem()
}

func (o ShellArrayOutput) ToShellArrayOutput() ShellArrayOutput {
	return o
}

func (o ShellArrayOutput) ToShellArrayOutputWithContext(ctx context.Context) ShellArrayOutput {
	return o
}

func (o ShellArrayOutput) Index(i pulumi.IntInput) ShellOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Shell {
		return vs[0].([]*Shell)[vs[1].(int)]
	}).(ShellOutput)
}

type ShellMapOutput struct{ *pulumi.OutputState }

func (ShellMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Shell)(nil)).Elem()
}

func (o ShellMapOutput) ToShellMapOutput() ShellMapOutput {
	return o
}

func (o ShellMapOutput) ToShellMapOutputWithContext(ctx context.Context) ShellMapOutput {
	return o
}

func (o ShellMapOutput) MapIndex(k pulumi.StringInput) ShellOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Shell {
		return vs[0].(map[string]*Shell)[vs[1].(string)]
	}).(ShellOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ShellInput)(nil)).Elem(), &Shell{})
	pulumi.RegisterInputType(reflect.TypeOf((*ShellArrayInput)(nil)).Elem(), ShellArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ShellMapInput)(nil)).Elem(), ShellMap{})
	pulumi.RegisterOutputType(ShellOutput{})
	pulumi.RegisterOutputType(ShellArrayOutput{})
	pulumi.RegisterOutputType(ShellMapOutput{})
}
