// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package installers

import (
	"context"
	"reflect"

	"errors"
	"github.com/corymhall/pulumi-provider-pde/sdk/go/pde/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Install global npm packages.
//
// This resource will create a local node project at the location you specify
// and will then symlink the node_modules/.bin directory so that all the executables
// are available globally.
type Npm struct {
	pulumi.CustomResourceState

	// The location of the node project
	Location pulumi.StringOutput `pulumi:"location"`
	// The npm package to install
	Package pulumi.StringOutput `pulumi:"package"`
	// The version of the package to install
	Version pulumi.StringPtrOutput `pulumi:"version"`
}

// NewNpm registers a new resource with the given unique name, arguments, and options.
func NewNpm(ctx *pulumi.Context,
	name string, args *NpmArgs, opts ...pulumi.ResourceOption) (*Npm, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Location == nil {
		return nil, errors.New("invalid value for required argument 'Location'")
	}
	if args.Package == nil {
		return nil, errors.New("invalid value for required argument 'Package'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Npm
	err := ctx.RegisterResource("pde:installers:Npm", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNpm gets an existing Npm resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNpm(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NpmState, opts ...pulumi.ResourceOption) (*Npm, error) {
	var resource Npm
	err := ctx.ReadResource("pde:installers:Npm", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Npm resources.
type npmState struct {
}

type NpmState struct {
}

func (NpmState) ElementType() reflect.Type {
	return reflect.TypeOf((*npmState)(nil)).Elem()
}

type npmArgs struct {
	// The location of the node project
	Location string `pulumi:"location"`
	// The npm package to install
	Package string `pulumi:"package"`
	// The version of the package to install
	Version *string `pulumi:"version"`
}

// The set of arguments for constructing a Npm resource.
type NpmArgs struct {
	// The location of the node project
	Location pulumi.StringInput
	// The npm package to install
	Package pulumi.StringInput
	// The version of the package to install
	Version pulumi.StringPtrInput
}

func (NpmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*npmArgs)(nil)).Elem()
}

type NpmInput interface {
	pulumi.Input

	ToNpmOutput() NpmOutput
	ToNpmOutputWithContext(ctx context.Context) NpmOutput
}

func (*Npm) ElementType() reflect.Type {
	return reflect.TypeOf((**Npm)(nil)).Elem()
}

func (i *Npm) ToNpmOutput() NpmOutput {
	return i.ToNpmOutputWithContext(context.Background())
}

func (i *Npm) ToNpmOutputWithContext(ctx context.Context) NpmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NpmOutput)
}

// NpmArrayInput is an input type that accepts NpmArray and NpmArrayOutput values.
// You can construct a concrete instance of `NpmArrayInput` via:
//
//	NpmArray{ NpmArgs{...} }
type NpmArrayInput interface {
	pulumi.Input

	ToNpmArrayOutput() NpmArrayOutput
	ToNpmArrayOutputWithContext(context.Context) NpmArrayOutput
}

type NpmArray []NpmInput

func (NpmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Npm)(nil)).Elem()
}

func (i NpmArray) ToNpmArrayOutput() NpmArrayOutput {
	return i.ToNpmArrayOutputWithContext(context.Background())
}

func (i NpmArray) ToNpmArrayOutputWithContext(ctx context.Context) NpmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NpmArrayOutput)
}

// NpmMapInput is an input type that accepts NpmMap and NpmMapOutput values.
// You can construct a concrete instance of `NpmMapInput` via:
//
//	NpmMap{ "key": NpmArgs{...} }
type NpmMapInput interface {
	pulumi.Input

	ToNpmMapOutput() NpmMapOutput
	ToNpmMapOutputWithContext(context.Context) NpmMapOutput
}

type NpmMap map[string]NpmInput

func (NpmMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Npm)(nil)).Elem()
}

func (i NpmMap) ToNpmMapOutput() NpmMapOutput {
	return i.ToNpmMapOutputWithContext(context.Background())
}

func (i NpmMap) ToNpmMapOutputWithContext(ctx context.Context) NpmMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NpmMapOutput)
}

type NpmOutput struct{ *pulumi.OutputState }

func (NpmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Npm)(nil)).Elem()
}

func (o NpmOutput) ToNpmOutput() NpmOutput {
	return o
}

func (o NpmOutput) ToNpmOutputWithContext(ctx context.Context) NpmOutput {
	return o
}

// The location of the node project
func (o NpmOutput) Location() pulumi.StringOutput {
	return o.ApplyT(func(v *Npm) pulumi.StringOutput { return v.Location }).(pulumi.StringOutput)
}

// The npm package to install
func (o NpmOutput) Package() pulumi.StringOutput {
	return o.ApplyT(func(v *Npm) pulumi.StringOutput { return v.Package }).(pulumi.StringOutput)
}

// The version of the package to install
func (o NpmOutput) Version() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Npm) pulumi.StringPtrOutput { return v.Version }).(pulumi.StringPtrOutput)
}

type NpmArrayOutput struct{ *pulumi.OutputState }

func (NpmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Npm)(nil)).Elem()
}

func (o NpmArrayOutput) ToNpmArrayOutput() NpmArrayOutput {
	return o
}

func (o NpmArrayOutput) ToNpmArrayOutputWithContext(ctx context.Context) NpmArrayOutput {
	return o
}

func (o NpmArrayOutput) Index(i pulumi.IntInput) NpmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Npm {
		return vs[0].([]*Npm)[vs[1].(int)]
	}).(NpmOutput)
}

type NpmMapOutput struct{ *pulumi.OutputState }

func (NpmMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Npm)(nil)).Elem()
}

func (o NpmMapOutput) ToNpmMapOutput() NpmMapOutput {
	return o
}

func (o NpmMapOutput) ToNpmMapOutputWithContext(ctx context.Context) NpmMapOutput {
	return o
}

func (o NpmMapOutput) MapIndex(k pulumi.StringInput) NpmOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Npm {
		return vs[0].(map[string]*Npm)[vs[1].(string)]
	}).(NpmOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NpmInput)(nil)).Elem(), &Npm{})
	pulumi.RegisterInputType(reflect.TypeOf((*NpmArrayInput)(nil)).Elem(), NpmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NpmMapInput)(nil)).Elem(), NpmMap{})
	pulumi.RegisterOutputType(NpmOutput{})
	pulumi.RegisterOutputType(NpmArrayOutput{})
	pulumi.RegisterOutputType(NpmMapOutput{})
}
